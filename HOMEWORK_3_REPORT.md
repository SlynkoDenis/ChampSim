# Homework 3. Q/A.

## 1. Объясните смысл и напишите формулы для следующих метрик производительности процессора: IPC, CPI, Performance, Dynamic Power.

* IPC - Instructions Per Cycle - среднее количество инструкций, исполняющееся за один такт процессора:
```
IPC = number_of_instructions / number_of_clock_cycles
```

* CPI - Cycles Per Instruction - среднее количество тактов, тратящееся на выполнение одной инструкции:
```
CPI = 1 / IPC = number_of_clock_cycles / number_of_instructions
```

* Performance - скорость исполнения программы; важная метрика при проектировании процессора, удобная для сравнения различных устройств:
```
Performance = 1 / execution_time = 1 / (number_of_clock_cycles * cycle_time) = f / number_of_clock_cycles = f / (CPI * number_of_instructions) = f * IPC / number_of_instructions
```

* Dynamic Power - динамическая потребляемая мощность; возникает за счёт зарядки/разрядки ёмкостей переходов транзисторов при их переключении:
```
Dynamic Power = 1 / 2 * C_ccf * V_dd ^ 2 * a * f
```

где `C_ccf` - ёмкость перехода транзисторов, `Vdd` - Voltage drain drain, `a` - среднее количество переключений транзистора за один такт.

## 2. Что такое суперскалярный (superscalar) процессор?

Суперскалярный процессор - процессор, способный обрабатывать 2 и более инструкции за цикл за счёт наличия дополнительных пайплайнов.

Пример: два пайплайна с общими стадиями Fetch и Decode, при этом один из пайплайнов может исполнять только ограниченный класс инструкций. На этапе Decode на основе инструкции и её независимости от предыдущей принимается решение об использовании второго пайплайна.

Недостаток: многие последовательные инструкции зависят друг от друга, что приводит к простаиванию второго пайплайна.

Альтернативы:
* VLIW (Very Long Instruction Word)
* Векторизация

## 3. Какие типы зависимостей по данным существуют? Приведите примеры аппаратных оптимизаций, которые позволяют сократить связанные задержки или разрешить каждый тип зависимостей.

* WAW - Write After Write - output dependency
* WAR - Write After Read - anti-dependency
* RAW - Read After Write - true dependency

Первые две зависимости называют _ложными зависимостями_ (_false dependencies_), так как последующие инструкции не используют данные предыдущих. За счёт этого данные зависимости можно устранить с помощью специальных аппаратных оптимизаций:

### Register Renaming

Аппаратура содержит значительно больше (порядка сотен против 32/64) _физических регистров_ в сравнении с реализуемой ISA. Это позволяет после стадии decode проводит переназначение регистров на физические таким образом, что пересечения регистров WAW и WAR удаётся избежать, за исключением случаев, когда отсутствуют свободные физические регистры. Переназначение регистров производится с помощью построения RAT - Register Aliases Table - таблицы соответствия логических регистров физическим

* Разрешение WAW:
```
before:
r1 = load #16
r2 = r1
r1 = load #20
r3 = r1

after:
r1 = load #16
r2 = r1
r4 = load #20
r3 = r4
```

* Разрешение WAR:
```
before:
r1 = r2
r2 = load #16
r3 = r2

after:
r1 = r2
r4 = load #16
r3 = r4
```

RAW называют _true dependency_, так как чтение не может исполниться раньше, чем данные были бы вычислены.

### Store to Load Forwarding

Данная оптимизация пробрасывает значение, записанное в Store Buffer (о нём будет рассказано ниже), в обход памяти напрямую в следующий load, что ускоряет исполнение.

## 4. С какой целью инструкцию Store разделяют на микро-операции STA (Store address calculation) и STD (Store data calculation)

* STA - вычисление адреса, обновление вычисленного адреса в Store Queue
* STD - перемещение данных в соответствующую ячейку Store Queue

Основная цель разделения на такие микро-операции заключается в ускорении относительно RAW зависимостей. Зачастую вычисление адреса store происходит раньше, чем вычисление данных; за счёт этого load, в случае отсутствия пересечения по адресам с store, могут не дожидаться полного исполнения инструкции store, а только STA.

## 5. Объясните назначение и функции следующих аппаратных структур: ROB, Scheduler Queue (Issue Queue, Reservation Station), RAT, PRF, Load Buffer, Store Buffer

* ROB - Re-Order Buffer (Instruction Window) - буфер инструкций, необходимый для корректной работы OOO (Out Of Order) execution, позволяющий поддерживать свойства линейного исполнения инструкций. Поддержание линейности вида исполнения необходимо:
  * Для сохранения свойств при исключениях - инструкции, логически следующие за "исключительной", не должны исполниться в реальности
  * Сохранения корректного состояния перед прерыванием
  * Дебаг
  * т.д.

Буфер представляет собой _спекулятивное состояние_ (_speculative state_), которое не влияет на _архитектурное состояние_ (_architectural state_) вплоть до момента покидания ROB - _retirement_. Покидание происходит при условии, что данная инструкция является самой старой в ROB и была исполнена, что и сохраняет видимость линейного исполнения.

В общем чем больше размер ROB, тем быстрее исполнение, так как больший размер ROB позволяет найти больше независимых инструкций, возможных к исполнению, и способен лучше скрывать задержки на промахи к кэши. Современные CPU имеют ROB размера порядка 200 инструкций. Однако слишком длинный ROB неэффективен, главным образом из-за необходимости очистки ROB при branch misprediction.

* Scheduler Queue (Issue Queue, Reservation Station) - по мере OOO исполнения требуется обходить все инструкции из ROB:
  * При помещении каждой инструкции в ROB для поиска data input для аллокации физического регистра
  * На каждом такте с целью идентификации готовых инструкций для отправки их на исполнение.

Эти факторы также накладывают ограничение на максимальную длину ROB. Для митигации данной проблемы используют Scheduler Queue - очередь еще не исполненных инструкций, которые иначе хранились бы в ROB. Так как необходимо проверить только неисполненные инструкции, которых в среднем 20-30% от длины ROB, то время на обход значительно сокращается. При этом инструкции из Scheduler Queue уходят в ROB после исполнения, а сам ROB используется только для восстановления линейного порядка перед retirement.

* RAT - Register Alias Table - таблица соответствия архитектурных регистров физическим регистрам данной микроархитектуры. Используется в рамках процесса Register Renaming, проводимом для избегания ложных зависимостей (WAW, WAR) между инструкциями.

* PRF - Physical Register File - регистровый файл физических регистров. Каждая ячейка ROB содержит данные о переименовании target регистра инструкции - указатель в PRF. Он используется для восстановления архитектурных регистров на retirement и записи в соответствующий физический регистр.

* Load Buffer, Store Buffer - буферы инструкций из **только** load и store соответственно, используемые для ускорения их исполнения с учётом зависимостей по данным. Store не исполняются спекулятивно; при этом load не обязаны дожидаться **всех** предшествующих store, а только тех, по которым есть зависимость (load по адресу, в который до этого производится store). Для определения пересечения по адресу необходимо проверить все адреса предшествующих store (как только они вычислены), и чтобы не проверять весь ROB, заводят Load Buffer и Store Buffer меньшего размера, проводя проверки с помощью них. При этом ROB используется для поддержания порядка.

## 6. Пусть каждая пятая инструкция в процессоре это Branch. Предсказатель переходов имеет точность 90%. Оцените, ROB какого максимального размера имеет смысл для такого процессора.

В случае branch misprediction необходимо очистить ROB и отменить исполненные спекулятивно неправильные инструкции, что делает OOO неэффективным. Эффективность размера ROB оценим по вероятности того, что в полностью заполненном ROB не произойдёт misprediction.

Пусть `L` - размер ROB. Тогда в среднем в ROB находится `num_of_branches = L * 1 / 5 = 0.2 * L` инструкций Branch.

Так как точность предсказателя составляет `p_success = 0.9`, то вероятность исполнения полного ROB без mispredict составляет

```
p_full_rob = p_success ^ num_of_branches = 0.9 ^ (0.2 * L).
```

Логарифмируя, получим выражение на `L`:

```
ln(p_full_rob) = 0.2 * L * ln(0.9)

L = ln(p_full_rob) / (0.2 * ln(0.9))
```

Так, приняв значение `p_full_rob = 0.9` как примлемое, получим `L = 5` - ROB длины 5. При этом на самом деле значение `p_full_rob = 0.9` вовсе не является приемлемым, так как означает flush ROB при каждом десятом заполнении.

## 7. Что такое Memory Disambiguation?

Это набор механизмов OOO процессоров, позволяющие устранить зависимости инструкций по памяти, тем самым улучшая ILP (Instruction Level Parallelism).

Примеры:
* Анализ зависимостей по памяти инструкций load и store (с использованием Load Buffer и Store Buffer)
* Store forwarding, позволяющий использовать значение store в последующем load
* Разбитие store на микро-операции STA и STD

## 8. В чём заключается проблема со спекулятивным исполнением Store инструкций?

При спекулятивном исполнении store инструкций необходимо поддерживать видимость их изначального относительного порядка, при этом обновлять реальную память только после того, как соответствующая инструкция покидает ROB. Проблема же заключается в невозможности отмены выполненной инструкции store, из-за чего store не могут быть исполнены спекулятивно (в отличие от load). Также store не могут быть переупорядочены между собой.

## 9. Что такое Store forwarding и Load speculation в OOO процессоре?

### Store Forwarding

Для тех инструкций load, которые ждут исполнения пересекающегося store - записи значения в кэш, необязательно поддерживать оригинальный линейный порядок. Поэтому возможно брать значение load сразу из исполнения соответствующей инструкции store, что приводит к ускорению.

### Load Speculation

Техника спекуляций store-load зависимостей. Позволяет не ждать всех предшествующих store, но исполняться спекулятивно, проверяя правильность предсказаний после исполнения микро-операции STA.

Спекуляции основываются на истории исполнения load инструкций; возможные тактики:
* Всегда исполнять ещё не посещённые load спекулятивно. Тогда в случае обнаружения пересечений сбрасывать исполненное и помечать данный load в blacklist инструкций, требуемых неспекулятивного исполнения
* Всегда исполнять ещё не посещённые load неспекулятивно. В случае отсутствия пересечений по адресам помещать load в whitelist для дальнейшего спекулятивного исполнения.

## 10. Что такое Simultaneous Multithreading?

Техника заключается в том, что при неизменном количестве core каждый из них разделяется на два логических.

Каждый из логических core поддерживает собственное архитектурное состояние (архитектурные регистры и instruction pointer).

Техника осуществляется за счёт разделения ресурсов единого пайплайна между логическими core:
* Replicated - ресурсы для поддержания состояния логического core; собственное hardware под каждый логический core
* Partitioned - разделение ресурсов без репликации (в Single Thread режиме могли бы быть объединены)
* Shared

Также может требоваться модификация отдельных hardware частей. Так, branch predictor относится к shared ресурсам, поэтому в нём необходимо учитывать thread id для избежания наложения.

Техника эффективнее с точки зрения hardware ресурсов (не всё требует репликации => дешевле, чем обычное увеличение количества core), однако приводит к уменьшению производительности каждого отдельного логического core, что в некоторых сценариях может уменьшить и общую производительность (например из-за cache thrashing)
